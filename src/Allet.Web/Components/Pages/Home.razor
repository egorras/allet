@page "/"
@using Allet.Web.Data
@using Allet.Web.Models
@using Microsoft.EntityFrameworkCore
@using Allet.Web.Components.Shared
@using Microsoft.Extensions.DependencyInjection
@inject IServiceScopeFactory ScopeFactory
@rendermode InteractiveServer

<PageTitle>Feed - Allet</PageTitle>

<h1>Feed</h1>
<p>New productions to review.</p>

@if (productions is null)
{
    <p><em>Loading...</em></p>
}
    <div class="row g-2 align-items-center mb-3">
        <div class="col-auto">
            <select class="form-select" @bind="selectedVenue" @bind:after="LoadAsync">
                <option value="">All venues</option>
                @foreach (var v in venues)
                {
                    <option value="@v">@v</option>
                }
            </select>
        </div>
    </div>

    @if (productions?.Count == 0)
    {
        <div class="alert alert-success mt-3">You're all caught up â€” no new productions to review.</div>
    }
else
{
    <div class="row mt-3">
        @foreach (var production in productions ?? [])
        {
            var activity = userActivities.TryGetValue(production.Id, out var act) ? act : null;
            <ProductionCard Production="production" Activity="activity" OnStatusChange="(status) => SetStatus(production.Id, status)" />
        }
    </div>
}

<ProductionStatusModal 
    Visible="@showStatusModal" 
    Production="@selectedProduction" 
    DesiredStatus="@desiredStatus" 
    OnCancel="@(() => showStatusModal = false)" 
    OnSave="@HandleStatusSave" />



@code {
    private const string currentUserId = "default";
    private List<Production>? productions;
    private Dictionary<int, UserProductionActivity> userActivities = [];

    private bool showStatusModal;
    private Production? selectedProduction;
    private ProductionUserStatus desiredStatus;

    private List<string> venues = [];
    private string selectedVenue = "";

    protected override async Task OnInitializedAsync()
    {
        using var scope = ScopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<AlletDbContext>();
        venues = await db.Venues
            .Where(v => v.Shows.Any(s => s.Production.ArtistId == null))
            .Select(v => v.Name).Distinct().OrderBy(n => n).ToListAsync();
        await LoadAsync();
    }

    private async Task LoadAsync()
    {
        var now = DateTime.UtcNow;
        
        using var scope = ScopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<AlletDbContext>();

        // Optimize: AsSplitQuery
        var query = db.Productions
            .AsNoTracking()
            .Include(p => p.Shows).ThenInclude(s => s.Venue)
            .Where(p => !db.UserActivities.Any(a => a.ProductionId == p.Id && a.UserId == currentUserId && a.Status != ProductionUserStatus.None))
            .Where(p => p.Shows.Any(s => !s.Date.HasValue || s.Date > now));

        if (!string.IsNullOrEmpty(selectedVenue))
        {
            query = query.Where(p => p.Shows.Any(s => s.Venue != null && s.Venue.Name == selectedVenue));
        }

        // Sort by the *next* upcoming show date.
        // AsSplitQuery removed to prevent Npgsql crash with complex OrderBy
        query = query.OrderBy(p => p.Shows.Where(s => s.Date > now).Min(s => s.Date));

        productions = await query.ToListAsync();
        
        var myActivities = await db.UserActivities
            .Include(a => a.Show)
            .Where(a => a.UserId == currentUserId)
            .ToListAsync();
        userActivities = myActivities.ToDictionary(a => a.ProductionId);
    }

    private async Task SetStatus(int productionId, ProductionUserStatus status)
    {
        using var scope = ScopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<AlletDbContext>();

        var activity = await db.UserActivities
            .FirstOrDefaultAsync(a => a.ProductionId == productionId && a.UserId == currentUserId);

        if (status == ProductionUserStatus.None)
        {
             // Direct remove/unset
            if (activity is not null)
            {
                db.UserActivities.Remove(activity);
                await db.SaveChangesAsync();
                await LoadAsync();
            }
        }
        else
        {
             // Open modal for Watched, Planned, or Archived (new action)
             var prod = productions?.FirstOrDefault(p => p.Id == productionId);
             if (prod != null)
             {
                 selectedProduction = prod;
                 desiredStatus = status;
                 showStatusModal = true;
             }
        }
    }

    private async Task HandleStatusSave(UserProductionActivity newActivity)
    {
        using var scope = ScopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<AlletDbContext>();

        var activity = await db.UserActivities
            .FirstOrDefaultAsync(a => a.ProductionId == newActivity.ProductionId && a.UserId == currentUserId);

        if (activity is null)
        {
            newActivity.UserId = currentUserId;
            // Ensure ID is 0 so it inserts
            newActivity.Id = 0; 
            db.UserActivities.Add(newActivity);
        }
        else
        {
            activity.Status = newActivity.Status;
            activity.Note = newActivity.Note;
            activity.WatchedDate = newActivity.WatchedDate;
            activity.ShowId = newActivity.ShowId;
            activity.UpdatedAt = DateTime.UtcNow;
        }

        await db.SaveChangesAsync();
        showStatusModal = false;
        await LoadAsync();
    }
}
